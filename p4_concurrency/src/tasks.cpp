#include <iostream>
#include <thread>
#include <future>
#include <cmath>
#include <memory>
#include <vector>

/* NOTE: SYNCHRONOUS VS ASYNCHRONOUS:
*
* A synchronous call is the one in which the function/call/procedure has to return
* before the next statement can be executed. What this means is that the function is
* blocking the rest of the code. In asynchronous calling, generally there would be
* multiple threads.
*/

/* TASK-BASED CONCURRENCY:
*
* Determining the optimal number of threads to use is a hard problem. It usually
* depends on the number of available cores wether it makes sense to execute code as
* a thread or in a sequential manner. The use of std::async (and thus tasks) take
* the burden of this decision away from the user and let the system decide wether
* to execute the code sequentially or as a thread. With tasks, the programmer
* decides what CAN be run in parallel in principle and the system then decides at
* runtime what WILL be run in parallel.
*
* With tasks, the system takes care of many details (e.g. join). With threads, the
* programmer is responsible for many details. As far as resources go, threads are
* usually more heavy-weight as they are generated by the operating system (OS). It
* takes time for the OS to be called and to allocate memory / stack / kernel data
* structures for the thread. Also, destroying the thread is expensive. Tasks on the
* other hand are more light-weight as they will be using a pool of already created
* threads (the "thread pool").
*/

// 1. remove std::promise as inout argument
double divideByNumber(double num, double denom)
{
  // print system id of worker thread
  std::cout << "Worker thread id = " << std::this_thread::get_id() << std::endl;

  std::this_thread::sleep_for(std::chrono::milliseconds(500)); // simulate work

  if (denom == 0)
    throw std::runtime_error("Exception from thread: Division by zero!");

  return num / denom;
}

void workerFunction(int n)
{
  // print system id of worker thread
  std::cout << "Worker thread id = " << std::this_thread::get_id() << std::endl;

  // perform work
  for (int i = 0; i < n; ++i)
  {
    sqrt(12345.6789);
  }
}

int main()
{

  /* THREADS VS. TASKS: STD::ASYNC()
  *
  * A disadvantage of the promise-future approach is that it is very cumbersome
  * (and involves a lot of boilerplate code) to pass the promise to the thread
  * function using an rvalue reference and std::move. For the straight-forward task
  * of returning data or exceptions from a worker thread to the parent thread
  * however, there is a simpler and more convenient way using std::async() instead
  * of std::thread().
  * 
  * 1. We are removing the promise from the argument list as well as the try-catch
  * block. Also, the return type of the function is changed from void to double as
  * the result of the computation will be channeled back to the main thread using a
  * simple return. After these changes, the function has no knowledge of threads,
  * nor of futures or promises - it is a simple function that takes two doubles as
  * arguments and returns a double as a result.
  * 
  * 2. In the main thread, we need to replace the call to std::thread with
  * std::async. Note that async returns a future, which we will use later in the
  * code to retrieve the value that is returned by the function. A promise, as with
  * std::thread, is no longer needed, so the code becomes much shorter.
  * 
  * NOTE: We do not need to call join() any more. With async, the thread destructor
  * will be called automatically - which reduces the risk of a concurrency bug.
  */

  // print system id of worker thread
  std::cout << "Main thread id = " << std::this_thread::get_id() << std::endl;

  // use async to start a task
  double num = 42.0, denom = 2.0;
  std::future<double> ftr = std::async(divideByNumber, num, denom);

  // to force syncronous execution of divideByNumber
  std::future<double> ftr1 = std::async(std::launch::deferred, divideByNumber, num, denom);

  // to force asyncronous execution of divideByNumber
  std::future<double> ftr2 = std::async(std::launch::async, divideByNumber, num, denom);

  // retrieve result within try-catch-block
  try
  {
    double result = ftr.get();
    std::cout << "Result = " << result << std::endl;
  }
  catch (std::runtime_error err)
  {
    std::cout << err.what() << std::endl;
  }

  /* COMPARING STD::ASYNC() VS STD::THREAD()
  *
  * Internally, std::async creates a promise, gets a future from it and runs a
  * template function that takes the promise, calls our function and then either
  * sets the value or the exception of that promise - depending on function behavior.
  * The code used internally by std::async is more or less identical to the code we
  * used in the previous example, except that this time it has been generated by
  * the compiler and it is hidden from us - which means that the code we write
  * appears much cleaner and leaner. Also, std::async makes it possible to control
  * the amount of concurrency by passing an optional launch parameter, which
  * enforces either synchronous or asynchronous behavior.
  */

  /* ASSESSING THE ADVATAGE OF PARALLEL EXECUTION:
  * 
  * It must be noted that starting and managing threads takes a significant amount
  * of time. It is therefore not a general advantage if computations are performed
  * in parallel: It must be carefully weighed with regard to the computational
  * effort whether parallelization makes sense.
  */


  // start time measurement
  // std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
  auto t1 = std::chrono::high_resolution_clock::now();
  
  // launch various tasks
  std::vector<std::future<void>> futures;
  int nLoops = 10e6, nThreads = 5;
  for (int i = 0; i < nThreads; ++i)
  {
    futures.emplace_back(std::async(std::launch::async, workerFunction, nLoops));
    // futures.emplace_back(std::async(std::launch::deferred, workerFunction, nLoops));
    // futures.emplace_back(std::async(std::launch::any, workerFunction, nLoops));
  }

  // wait for tasks to complete
  for (const std::future<void> &ftr : futures)
    ftr.wait();

  // stop time measurement and print execution time
  auto t2 = std::chrono::high_resolution_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count();
  std::cout << "Execution finished after " << duration <<" microseconds" << std::endl;

  return 0;
}